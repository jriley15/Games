export interface VectorConstructable<T> {
    new (x: number, y: number): T;
}
/**
 * The class that all other vector representations are derived from.
 *
 * Contains the core implementation for all methods that will be exposed by
 * vector instances.
 *
 * Example of creating a custom implementation:
 *
 * ```ts
 * import { AbstractVector } from "./AbstractVector"
 *
 * export class MyCustomVector extends AbstractVector {
 *  constructor (x: number, y: number) {
 *    super(CustomVectorType)
 *  }
 * }
 * ```
 */
export declare abstract class AbstractVector {
    protected ctor: VectorConstructable<AbstractVector>;
    constructor(ctor: VectorConstructable<AbstractVector>);
    abstract x: number;
    abstract y: number;
    /**
     * Set both x and y axis value
     * @param x   New x val
     * @param y   New y val
     */
    setAxes(x: number, y: number): this;
    /**
     * Getter for x the axis value
     */
    getX(): number;
    /**
     * Setter for x axis value
     */
    setX(x: number): this;
    /**
     * Getter for y axis value
     */
    getY(): number;
    /**
     * Setter for y axis.
     */
    setY(y: number): this;
    /**
     * Return the vector as a formatted string, e.g "(0, 4)"
     */
    toString(round?: boolean): string;
    /**
     * Return an Array containing the vector axes, e.g [0, 4]
     */
    toArray(): number[];
    /**
     * Return an Object containing the vector axes, e.g { x: 0, y: 4 }
     */
    toObject(): {
        x: number;
        y: number;
    };
    /**
     * Add the provided vector to this one
     */
    add(vec: AbstractVector): this;
    /**
     * Subtract the provided vector from this one
     */
    subtract(vec: AbstractVector): this;
    /**
     * Check if the provided vector equal to this one
     */
    equals(vec: AbstractVector): boolean;
    /**
     * Multiply this vector by the provided vector
     */
    multiplyByVector(vec: AbstractVector): this;
    /**
     * Multiply this vector by the provided vector
     */
    mulV(vec: AbstractVector): this;
    /**
     * Divide this vector by the provided vector
     */
    divideByVector(vec: AbstractVector): this;
    /**
     * Divide this vector by the provided vector
     */
    divV(v: AbstractVector): this;
    /**
     * Multiply this vector by the provided number
     */
    multiplyByScalar(n: number): this;
    /**
     * Multiply this vector by the provided number
     */
    mulS(n: number): this;
    /**
     * Divive this vector by the provided number
     */
    divideByScalar(n: number): this;
    /**
     * Divive this vector by the provided number
     */
    divS(n: number): this;
    /**
     * Normalise this vector
     */
    normalise(): this;
    /**
     * For American spelling. Same as unit/normalise function
     */
    normalize(): this;
    /**
     * The same as normalise and normalize
     */
    unit(): this;
    /**
     * Returns the magnitude (length) of this vector
     */
    magnitude(): number;
    /**
     * Returns the magnitude (length) of this vector
     */
    length(): number;
    /**
     * Returns the squred length of this vector
     */
    lengthSq(): number;
    /**
     * Returns the dot product of this vector by another
     */
    dot(vec: AbstractVector): number;
    /**
     * Returns the cross product of this vector by another.
     */
    cross(vec: AbstractVector): number;
    /**
     * Reverses this vector i.e multiplies it by -1
     */
    reverse(): this;
    /**
     * Set the vector axes values to absolute values
     */
    abs(): this;
    /**
     * Zeroes the vector i.e sets all axes to 0
     */
    zero(): this;
    /**
     * Returns the distance between this vector and another
     */
    distance(v: AbstractVector): number;
    /**
     * Rotates the vetor by provided radians
     */
    rotate(rads: number): this;
    /**
     * Rounds this vector to n decimal places
     */
    round(n?: number): this;
    /**
     * Returns a copy of this vector
     */
    clone(): AbstractVector;
}
